{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Trinj/OneDrive/Desktop/fisc-financial-backend/src/utils/finance.ts"],"sourcesContent":["import { Bucket } from '@/hooks/useHorizon';\r\n\r\nexport interface ProjectedBucket extends Bucket {\r\n    projected_balance: number;\r\n}\r\n\r\n/**\r\n * Calculates projected bucket balances based on income input.\r\n * - Uses the user's explicit 'percentage' for distribution.\r\n * - Rounds to 2 decimal places to act like real money.\r\n * - Enforces the \"Hard Cap\" rule (stops at target_amount).\r\n */\r\nexport const calculateProjections = (income: number, buckets: Bucket[]): ProjectedBucket[] => {\r\n    // If no income or negative, return buckets with projected = current\r\n    if (!income || income <= 0) {\r\n        return buckets.map(b => ({\r\n            ...b,\r\n            projected_balance: b.current_balance || 0\r\n        }));\r\n    }\r\n\r\n    return buckets.map(bucket => {\r\n        // 1. Calculate share based on the Database Percentage (e.g., 50)\r\n        // We expect bucket.percentage to be a number like 50, 30, 20.\r\n        const percentage = bucket.percentage || 0;\r\n        let potentialAdd = income * (percentage / 100);\r\n\r\n        // 2. Round down to 2 decimals immediately (Money Logic)\r\n        // This prevents numbers like 322.581\r\n        potentialAdd = Math.floor(potentialAdd * 100) / 100;\r\n\r\n        const currentBalance = bucket.current_balance || 0;\r\n\r\n        // 3. HARD CAP RULE:\r\n        // Calculate how much space is strictly left in the bucket.\r\n        const spaceRemaining = Math.max(0, bucket.target_amount - currentBalance);\r\n\r\n        // 4. The actual amount to add is the smaller of:\r\n        //    a) The calculated percentage share\r\n        //    b) The remaining space (to prevent overflow)\r\n        const actualAdd = Math.min(potentialAdd, spaceRemaining);\r\n\r\n        return {\r\n            ...bucket,\r\n            projected_balance: currentBalance + actualAdd\r\n        };\r\n    });\r\n};"],"names":[],"mappings":";;;;AAYO,MAAM,uBAAuB,CAAC,QAAgB;IACjD,oEAAoE;IACpE,IAAI,CAAC,UAAU,UAAU,GAAG;QACxB,OAAO,QAAQ,GAAG,CAAC,CAAA,IAAK,CAAC;gBACrB,GAAG,CAAC;gBACJ,mBAAmB,EAAE,eAAe,IAAI;YAC5C,CAAC;IACL;IAEA,OAAO,QAAQ,GAAG,CAAC,CAAA;QACf,iEAAiE;QACjE,8DAA8D;QAC9D,MAAM,aAAa,OAAO,UAAU,IAAI;QACxC,IAAI,eAAe,SAAS,CAAC,aAAa,GAAG;QAE7C,wDAAwD;QACxD,qCAAqC;QACrC,eAAe,KAAK,KAAK,CAAC,eAAe,OAAO;QAEhD,MAAM,iBAAiB,OAAO,eAAe,IAAI;QAEjD,oBAAoB;QACpB,2DAA2D;QAC3D,MAAM,iBAAiB,KAAK,GAAG,CAAC,GAAG,OAAO,aAAa,GAAG;QAE1D,iDAAiD;QACjD,wCAAwC;QACxC,kDAAkD;QAClD,MAAM,YAAY,KAAK,GAAG,CAAC,cAAc;QAEzC,OAAO;YACH,GAAG,MAAM;YACT,mBAAmB,iBAAiB;QACxC;IACJ;AACJ"}},
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Trinj/OneDrive/Desktop/fisc-financial-backend/src/app/actions/allocate.ts"],"sourcesContent":["'use server';\r\n\r\nimport { createClient } from '@supabase/supabase-js';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { Bucket } from '@/hooks/useHorizon';\r\nimport { calculateProjections } from '@/utils/finance';\r\n\r\n// Initialize Supabase Admin Client (Service Role)\r\n// This bypasses RLS to ensure we can update any user's data securely from the server\r\nconst supabaseAdmin = createClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.SUPABASE_SERVICE_ROLE_KEY!\r\n);\r\n\r\n/**\r\n * Allocates income to buckets and updates the database.\r\n * \r\n * @param userId The ID of the user (not strictly used if buckets have IDs, but good for validation if needed)\r\n * @param income The amount of income to allocate\r\n * @param buckets The current state of buckets (mostly for IDs and targets)\r\n */\r\nexport async function allocateIncome(userId: string, income: number, buckets: Bucket[]) {\r\n    try {\r\n        if (!income || income <= 0) {\r\n            throw new Error(\"Invalid income amount.\");\r\n        }\r\n\r\n        if (!buckets || buckets.length === 0) {\r\n            throw new Error(\"No buckets to allocate to.\");\r\n        }\r\n\r\n        // Get authenticated user\r\n        const supabase = await createClient();\r\n        const { data: { user }, error: authError } = await supabase.auth.getUser();\r\n\r\n        if (authError || !user) {\r\n            throw new Error(\"Unauthorized\");\r\n        }\r\n\r\n        const realUserId = user.id;\r\n\r\n        // 1. Recalculate projections server-side for safety\r\n        // We trust the bucket IDs and Targets from the client (for now), but we recalculate the split.\r\n        // In a real app, we might re-fetch buckets from DB to ensure targets haven't changed.\r\n        // For this MVP, we'll use the passed buckets but recalculate the math.\r\n        const projectedBuckets = calculateProjections(income, buckets);\r\n\r\n        // 2. Perform updates sequentially\r\n        // Supabase doesn't support multi-table transactions via JS client easily without RPC.\r\n        // Sequential updates are fine for this scale.\r\n\r\n        const updates = projectedBuckets.map(async (bucket) => {\r\n            // Only update if there's a change or strictly if projected > current?\r\n            // Actually, we want to commit the projected_balance as the new current_balance.\r\n\r\n            const { error } = await supabase\r\n                .from('allocation_buckets')\r\n                .update({ current_balance: bucket.projected_balance })\r\n                .eq('id', bucket.id)\r\n                .eq('user_id', realUserId); // Ensure we only touch rows for this user\r\n\r\n            if (error) {\r\n                console.error(`Failed to update bucket ${bucket.name}:`, error);\r\n                throw new Error(`Failed to update bucket ${bucket.name}`);\r\n            }\r\n        });\r\n\r\n        await Promise.all(updates);\r\n\r\n        // 3. Revalidate the dashboard\r\n        revalidatePath('/horizon');\r\n\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error(\"Allocation Error:\", error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAEA;;;;;;AAEA,kDAAkD;AAClD,qFAAqF;AACrF,MAAM,gBAAgB,IAAA,8LAAY,gFAE9B,QAAQ,GAAG,CAAC,yBAAyB;AAUlC,eAAe,eAAe,MAAc,EAAE,MAAc,EAAE,OAAiB;IAClF,IAAI;QACA,IAAI,CAAC,UAAU,UAAU,GAAG;YACxB,MAAM,IAAI,MAAM;QACpB;QAEA,IAAI,CAAC,WAAW,QAAQ,MAAM,KAAK,GAAG;YAClC,MAAM,IAAI,MAAM;QACpB;QAEA,yBAAyB;QACzB,MAAM,WAAW,MAAM,IAAA,8LAAY;QACnC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,OAAO,SAAS,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAExE,IAAI,aAAa,CAAC,MAAM;YACpB,MAAM,IAAI,MAAM;QACpB;QAEA,MAAM,aAAa,KAAK,EAAE;QAE1B,oDAAoD;QACpD,+FAA+F;QAC/F,sFAAsF;QACtF,uEAAuE;QACvE,MAAM,mBAAmB,IAAA,+IAAoB,EAAC,QAAQ;QAEtD,kCAAkC;QAClC,sFAAsF;QACtF,8CAA8C;QAE9C,MAAM,UAAU,iBAAiB,GAAG,CAAC,OAAO;YACxC,sEAAsE;YACtE,gFAAgF;YAEhF,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,SACnB,IAAI,CAAC,sBACL,MAAM,CAAC;gBAAE,iBAAiB,OAAO,iBAAiB;YAAC,GACnD,EAAE,CAAC,MAAM,OAAO,EAAE,EAClB,EAAE,CAAC,WAAW,aAAa,0CAA0C;YAE1E,IAAI,OAAO;gBACP,QAAQ,KAAK,CAAC,CAAC,wBAAwB,EAAE,OAAO,IAAI,CAAC,CAAC,CAAC,EAAE;gBACzD,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,OAAO,IAAI,EAAE;YAC5D;QACJ;QAEA,MAAM,QAAQ,GAAG,CAAC;QAElB,8BAA8B;QAC9B,IAAA,+IAAc,EAAC;QAEf,OAAO;YAAE,SAAS;QAAK;IAC3B,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO;YAAE,SAAS;YAAO,OAAO,MAAM,OAAO;QAAC;IAClD;AACJ;;;IAxDsB;;AAAA,+OAAA"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Trinj/OneDrive/Desktop/fisc-financial-backend/.next-internal/server/app/horizon/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {allocateIncome as '70649e00ac30b0421d1341c642b7ec0b860a4a3de3'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}